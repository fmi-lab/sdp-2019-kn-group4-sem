### Двоични дървета

1. Да се провери дали дадено двоично дърво е балансирано
1. Да се провери дали дадено двоично дърво e пълно (full според [Wikipedia](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)).
1. Да се провери дали дадено двоично дърво е пълно (complete / almost complete според [Wikipedia](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)).
1. Да се провери дали дадено двоично дърво има свойството на heap
1. Да се намери размерът на най-голямото поддърво, което има свойството на heap
1. Нека са дадени две двоични дървета. Да се провери дали имат еднаква структура (т.е. дали нарисувано дървото изглежда по същия начин, но евентуално с други стойности по възлите)

1. Нека са дадени два низа с еднаква дължина, които представляват елементите на двоично дърво от символи съответно при обхождане ляво-дясно-корен и ляво-корен-дясно. 
   Да се възстанови дървото. (Приемаме, че всички елементи в дървото са различни)
   
   Примерни низове: `PSBKRJCMDE` и `SKBPCJRDME`


1. Двоично дърво можем да представим еднозначно като низ по следния начин:
     * ако възелът е листо, `(data () ())`
     * ако не е листо, `(data left right)`, където left и right са представянията съответно на лявото и дясното поддърво.

   Да се напишат две функции serialize и deserialize, които съответно построяват низ по зададено двоично дърво и обратното.

   Задачата да се реши и със стек вместо с рекурсия.
   
### Двоични дървета за търсене (binary search trees)
1. По дадено BST с цели числа да се намери броят елементи, по-големи от дадено число x.
1. Да се провери дали даденo число x се съдържа в BST.
1. Да се провери дали дадено двоично дърво има наредба като BST.
1. Да се имплементира TreeMap.

